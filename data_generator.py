#模拟数据
import numpy as np
inputDim=[4,5,6]    #每层交换机个数,3:最高层个数，6：最底层个数；因为我们的推导是从顶层向底层推，所以我把array倒过来
D=[np.random.rand(inputDim[i+1]) for i in range(len(inputDim)-1)] #交换机个数为4、5、6的层的单个交换机延时
structure=[[np.random.randint(0, inputDim[i]-1) for _ in range(inputDim[i+1])] for i in range(len(inputDim)-1)]  
#structure: [[1, 2, 1, 1], [0, 3, 3, 3, 0], [1, 0, 4, 0, 3, 0]]  
#其中[1, 2, 1, 1]指的是交换机个数为4的层与交换机个数为3的层之间的交换机连接情况；其中的第i个数a[i]表示交换机个数为4的层中第i-1台交换机与换机个数为3的层中第a[i]台交换机相连
T=[np.zeros([inputDim[i],inputDim[i]]) for i in range(len(inputDim))]
T[0]=np.random.rand(inputDim[0],inputDim[0])
for k in range(1,len(inputDim)):
    for i in range(inputDim[k]):
        for j in range(inputDim[k]):
            T[k][i][j]=D[k-1][i]+D[k-1][j]+T[k-1][structure[k-1][i]][structure[k-1][j]]
T#各层的同级交换机间通信时间, 最开始展现的是PSW，最后print的是ASW


结果：

[array([[0.66031113, 0.24896055, 0.24708453, 0.48168455],
        [0.34221248, 0.9883452 , 0.61101134, 0.41428819],
        [0.60565228, 0.5528978 , 0.87223724, 0.06479939],
        [0.50377861, 0.939227  , 0.97832708, 0.84266789]]),
 array([[2.6123581 , 2.27508047, 1.64093525, 2.40532692, 1.9629779 ],
        [1.91651272, 2.25904665, 1.26630533, 2.3892931 , 1.26713253],
        [1.69904878, 1.35955726, 1.42429924, 1.48980371, 1.04966859],
        [2.04675916, 2.3892931 , 1.39655178, 2.51953955, 1.39737897],
        [1.9629779 , 1.62570028, 0.99155506, 1.75594673, 1.31359771]]),
 array([[3.77046   , 3.32907698, 3.08694783, 2.95074746, 2.69895814,
         3.82528476],
        [3.68764473, 3.92607328, 3.68394413, 3.22652829, 2.97473897,
         3.74246949],
        [3.44551559, 3.68394413, 3.44181498, 2.98439914, 2.73260982,
         3.50034034],
        [3.04399939, 3.28464182, 3.04251268, 3.28177014, 3.02998082,
         3.09882414],
        [2.79221007, 3.03285251, 2.79072336, 3.02998082, 2.77819151,
         2.84703482],
        [3.82528476, 3.38390174, 3.14177259, 3.00557221, 2.7537829 ,
         3.88010951]])]